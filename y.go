// Code generated by goyacc -p ip ip.y. DO NOT EDIT.

//line ip.y:2

package iprange

import (
	"encoding/binary"
	__yyfmt__ "fmt"
	"net"

	"github.com/pkg/errors"
)

//line ip.y:3

type AddressRangeList []AddressRange

type AddressRange struct {
	Min net.IP
	Max net.IP
}

type octetRange struct {
	min byte
	max byte
}

const (
	ipV4MaskLength = 32
	maxMaskValue   = ipV4MaskLength
)

//line ip.y:31
type ipSymType struct {
	yys       int
	byteValue byte
	octRange  octetRange
	addrRange AddressRange
	result    AddressRangeList
	ipMask    net.IPMask
}

const NUM = 57346

var ipToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"NUM",
	"','",
	"' '",
	"'/'",
	"'.'",
	"'*'",
	"'-'",
}

var ipStatenames = [...]string{}

const ipEofCode = 1
const ipErrCode = 2
const ipInitialStackSize = 16

//line ip.y:104

// ParseList takes a list of target specifications and returns a list of ranges,
// even if the list contains a single element.
func ParseList(in string) (AddressRangeList, error) {
	lex := &ipLex{line: []byte(in)}
	errCode := ipParse(lex)
	if errCode != 0 || lex.err != nil {
		return nil, errors.Wrap(lex.err, "could not parse target")
	}
	return lex.output, nil
}

// Parse takes a single target specification and returns a range. It effectively calls ParseList
// and returns the first result
func Parse(in string) (*AddressRange, error) {
	l, err := ParseList(in)
	if err != nil {
		return nil, err
	}
	return &l[0], nil
}

//line yacctab:1
var ipExca = [...]int8{
	-1, 1,
	1, -1,
	-2, 0,
}

const ipPrivate = 57344

const ipLast = 23

var ipAct = [...]int8{
	4, 5, 12, 21, 2, 10, 6, 19, 11, 14,
	9, 18, 17, 13, 16, 8, 1, 7, 3, 15,
	20, 0, 22,
}

var ipPact = [...]int16{
	-3, 5, -1000, -2, 0, -8, -1000, -1000, -3, 3,
	10, -3, 7, -1000, -1000, -1000, -1000, -1, -1000, -3,
	-5, -3, -1000,
}

var ipPgo = [...]int8{
	0, 19, 18, 4, 0, 17, 16, 15,
}

var ipR1 = [...]int8{
	0, 6, 6, 7, 7, 3, 3, 2, 4, 4,
	4, 5, 1,
}

var ipR2 = [...]int8{
	0, 1, 3, 1, 2, 3, 1, 7, 1, 1,
	1, 3, 1,
}

var ipChk = [...]int16{
	-1000, -6, -3, -2, -4, 4, 9, -5, -7, 5,
	7, 8, 10, -3, 6, -1, 4, -4, 4, 8,
	-4, 8, -4,
}

var ipDef = [...]int8{
	0, -2, 1, 6, 0, 8, 9, 10, 0, 3,
	0, 0, 0, 2, 4, 5, 12, 0, 11, 0,
	0, 0, 7,
}

var ipTok1 = [...]int8{
	1, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 6, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 9, 3, 5, 10, 8, 7,
}

var ipTok2 = [...]int8{
	2, 3, 4,
}

var ipTok3 = [...]int8{
	0,
}

var ipErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	ipDebug        = 0
	ipErrorVerbose = false
)

type ipLexer interface {
	Lex(lval *ipSymType) int
	Error(s string)
}

type ipParser interface {
	Parse(ipLexer) int
	Lookahead() int
}

type ipParserImpl struct {
	lval  ipSymType
	stack [ipInitialStackSize]ipSymType
	char  int
}

func (p *ipParserImpl) Lookahead() int {
	return p.char
}

func ipNewParser() ipParser {
	return &ipParserImpl{}
}

const ipFlag = -1000

func ipTokname(c int) string {
	if c >= 1 && c-1 < len(ipToknames) {
		if ipToknames[c-1] != "" {
			return ipToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func ipStatname(s int) string {
	if s >= 0 && s < len(ipStatenames) {
		if ipStatenames[s] != "" {
			return ipStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func ipErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !ipErrorVerbose {
		return "syntax error"
	}

	for _, e := range ipErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + ipTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := int(ipPact[state])
	for tok := TOKSTART; tok-1 < len(ipToknames); tok++ {
		if n := base + tok; n >= 0 && n < ipLast && int(ipChk[int(ipAct[n])]) == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if ipDef[state] == -2 {
		i := 0
		for ipExca[i] != -1 || int(ipExca[i+1]) != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; ipExca[i] >= 0; i += 2 {
			tok := int(ipExca[i])
			if tok < TOKSTART || ipExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if ipExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += ipTokname(tok)
	}
	return res
}

func iplex1(lex ipLexer, lval *ipSymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = int(ipTok1[0])
		goto out
	}
	if char < len(ipTok1) {
		token = int(ipTok1[char])
		goto out
	}
	if char >= ipPrivate {
		if char < ipPrivate+len(ipTok2) {
			token = int(ipTok2[char-ipPrivate])
			goto out
		}
	}
	for i := 0; i < len(ipTok3); i += 2 {
		token = int(ipTok3[i+0])
		if token == char {
			token = int(ipTok3[i+1])
			goto out
		}
	}

out:
	if token == 0 {
		token = int(ipTok2[1]) /* unknown char */
	}
	if ipDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", ipTokname(token), uint(char))
	}
	return char, token
}

func ipParse(iplex ipLexer) int {
	return ipNewParser().Parse(iplex)
}

func (iprcvr *ipParserImpl) Parse(iplex ipLexer) int {
	var ipn int
	var ipVAL ipSymType
	var ipDollar []ipSymType
	_ = ipDollar // silence set and not used
	ipS := iprcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	ipstate := 0
	iprcvr.char = -1
	iptoken := -1 // iprcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		ipstate = -1
		iprcvr.char = -1
		iptoken = -1
	}()
	ipp := -1
	goto ipstack

ret0:
	return 0

ret1:
	return 1

ipstack:
	/* put a state and value onto the stack */
	if ipDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", ipTokname(iptoken), ipStatname(ipstate))
	}

	ipp++
	if ipp >= len(ipS) {
		nyys := make([]ipSymType, len(ipS)*2)
		copy(nyys, ipS)
		ipS = nyys
	}
	ipS[ipp] = ipVAL
	ipS[ipp].yys = ipstate

ipnewstate:
	ipn = int(ipPact[ipstate])
	if ipn <= ipFlag {
		goto ipdefault /* simple state */
	}
	if iprcvr.char < 0 {
		iprcvr.char, iptoken = iplex1(iplex, &iprcvr.lval)
	}
	ipn += iptoken
	if ipn < 0 || ipn >= ipLast {
		goto ipdefault
	}
	ipn = int(ipAct[ipn])
	if int(ipChk[ipn]) == iptoken { /* valid shift */
		iprcvr.char = -1
		iptoken = -1
		ipVAL = iprcvr.lval
		ipstate = ipn
		if Errflag > 0 {
			Errflag--
		}
		goto ipstack
	}

ipdefault:
	/* default state action */
	ipn = int(ipDef[ipstate])
	if ipn == -2 {
		if iprcvr.char < 0 {
			iprcvr.char, iptoken = iplex1(iplex, &iprcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if ipExca[xi+0] == -1 && int(ipExca[xi+1]) == ipstate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			ipn = int(ipExca[xi+0])
			if ipn < 0 || ipn == iptoken {
				break
			}
		}
		ipn = int(ipExca[xi+1])
		if ipn < 0 {
			goto ret0
		}
	}
	if ipn == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			iplex.Error(ipErrorMessage(ipstate, iptoken))
			Nerrs++
			if ipDebug >= 1 {
				__yyfmt__.Printf("%s", ipStatname(ipstate))
				__yyfmt__.Printf(" saw %s\n", ipTokname(iptoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for ipp >= 0 {
				ipn = int(ipPact[ipS[ipp].yys]) + ipErrCode
				if ipn >= 0 && ipn < ipLast {
					ipstate = int(ipAct[ipn]) /* simulate a shift of "error" */
					if int(ipChk[ipstate]) == ipErrCode {
						goto ipstack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if ipDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", ipS[ipp].yys)
				}
				ipp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if ipDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", ipTokname(iptoken))
			}
			if iptoken == ipEofCode {
				goto ret1
			}
			iprcvr.char = -1
			iptoken = -1
			goto ipnewstate /* try again in the same state */
		}
	}

	/* reduction by production ipn */
	if ipDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", ipn, ipStatname(ipstate))
	}

	ipnt := ipn
	ippt := ipp
	_ = ippt // guard against "declared and not used"

	ipp -= int(ipR2[ipn])
	// ipp is now the index of $0. Perform the default action. Iff the
	// reduced production is Îµ, $1 is possibly out of range.
	if ipp+1 >= len(ipS) {
		nyys := make([]ipSymType, len(ipS)*2)
		copy(nyys, ipS)
		ipS = nyys
	}
	ipVAL = ipS[ipp+1]

	/* consult goto table to find next state */
	ipn = int(ipR1[ipn])
	ipg := int(ipPgo[ipn])
	ipj := ipg + ipS[ipp].yys + 1

	if ipj >= ipLast {
		ipstate = int(ipAct[ipg])
	} else {
		ipstate = int(ipAct[ipj])
		if int(ipChk[ipstate]) != -ipn {
			ipstate = int(ipAct[ipg])
		}
	}
	// dummy call; replaced with literal code
	switch ipnt {

	case 1:
		ipDollar = ipS[ippt-1 : ippt+1]
//line ip.y:48
		{
			ipVAL.result = append(ipVAL.result, ipDollar[1].addrRange)
			iplex.(*ipLex).output = ipVAL.result
		}
	case 2:
		ipDollar = ipS[ippt-3 : ippt+1]
//line ip.y:53
		{
			ipVAL.result = append(ipDollar[1].result, ipDollar[3].addrRange)
			iplex.(*ipLex).output = ipVAL.result
		}
	case 5:
		ipDollar = ipS[ippt-3 : ippt+1]
//line ip.y:61
		{
			mask := ipDollar[3].ipMask
			min := ipDollar[1].addrRange.Min.Mask(mask)
			maxInt := binary.BigEndian.Uint32([]byte(min)) +
				0xffffffff -
				binary.BigEndian.Uint32([]byte(mask))
			maxBytes := make([]byte, 4)
			binary.BigEndian.PutUint32(maxBytes, maxInt)
			maxBytes = maxBytes[len(maxBytes)-4:]
			max := net.IP(maxBytes)
			ipVAL.addrRange = AddressRange{
				Min: min.To4(),
				Max: max.To4(),
			}
		}
	case 6:
		ipDollar = ipS[ippt-1 : ippt+1]
//line ip.y:77
		{
			ipVAL.addrRange = ipDollar[1].addrRange
		}
	case 7:
		ipDollar = ipS[ippt-7 : ippt+1]
//line ip.y:82
		{
			ipVAL.addrRange = AddressRange{
				Min: net.IPv4(ipDollar[1].octRange.min, ipDollar[3].octRange.min, ipDollar[5].octRange.min, ipDollar[7].octRange.min).To4(),
				Max: net.IPv4(ipDollar[1].octRange.max, ipDollar[3].octRange.max, ipDollar[5].octRange.max, ipDollar[7].octRange.max).To4(),
			}
		}
	case 8:
		ipDollar = ipS[ippt-1 : ippt+1]
//line ip.y:89
		{
			ipVAL.octRange = octetRange{ipDollar[1].byteValue, ipDollar[1].byteValue}
		}
	case 9:
		ipDollar = ipS[ippt-1 : ippt+1]
//line ip.y:90
		{
			ipVAL.octRange = octetRange{0, 255}
		}
	case 10:
		ipDollar = ipS[ippt-1 : ippt+1]
//line ip.y:91
		{
			ipVAL.octRange = ipDollar[1].octRange
		}
	case 11:
		ipDollar = ipS[ippt-3 : ippt+1]
//line ip.y:93
		{
			ipVAL.octRange = octetRange{ipDollar[1].byteValue, ipDollar[3].byteValue}
		}
	case 12:
		ipDollar = ipS[ippt-1 : ippt+1]
//line ip.y:96
		{
			if ipDollar[1].byteValue > maxMaskValue {
				ipVAL.ipMask = net.CIDRMask(maxMaskValue, ipV4MaskLength)
				break
			}
			ipVAL.ipMask = net.CIDRMask(int(ipDollar[1].byteValue), ipV4MaskLength)
		}
	}
	goto ipstack /* stack new state and value */
}
